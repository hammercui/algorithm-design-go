# dynamic programming
>动态规划问题,将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。

两个最重要特点：
1. 无后效性：指历史不影响未来，只有当前状态影响未来。比如阶段1，2，3,阶段3只收到2的输入影响，与
阶段1的输入无关。
2. 存在指标函数：即最优解一定是某个子问题的最优解，存在最优子结构。

解题思路：
1. 每阶段只有一个状态，递推算法
2. 每阶段多个状态，每个阶段的最优状态从上一阶段获得，贪心算法
3. 每阶段多个状态，每个阶段的最优状态，由之前的所有阶段组合得到，搜索算法
4. 每阶段多个状态，每个阶段的最优解，可以从之前的某个阶段或状态直接获得，而不用管之前这个状态
怎么获得，动态规划

对于状态x，最小费用为f(x),我们的目标是f(T);找出f(x)与那些局面有关，即为p,可以通过
f(p)推导出f(T)，这个推导或者状态转移可以用多项式能表达。那么这就是一个dp算法。

> 每一个阶段可能包括很多状态，前后阶段的状态通过决策联系在一起。如果要利用前阶段子问题的结果解决现阶段的子问题，必须要能够建立前后阶段状态的转移关系，最好可以通过方程表示。用专业术语我们又叫做
>"状态转移方程”

### 实战1： 最长上升子序列LIS问题
>给定长度为n的序列a，从a中抽取出一个子序列，这个子序列需要单调递增。问最长的上升子序列（LIS）的长度。
e.g. 1,5,3,4,6,9,7,8的LIS为1,3,4,6,7,8，长度为6。

解题思路：

1. 我是谁?代表一种状态
2. 我从哪里推过来?ax在ap之后，肯定能构造一个以ax结尾的子序列，长度为f(p)+1
3. 我到哪里去?设计转移，从当前状态转移到结果，即算法

### 实战2：最大子序和
>

